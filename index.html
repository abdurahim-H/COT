<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JSON → Steps (Per-Item ZIP)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 2rem; line-height: 1.4; }
    h1 { margin-top: 0; }
    .card { border: 1px solid #ccc; border-radius: 8px; padding: 1rem; max-width: 800px; }
    .row { display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; }
    input[type="file"] { padding: .5rem; }
    button { padding: .6rem 1rem; border-radius: 6px; border: 1px solid #888; background: #f3f3f3; cursor: pointer; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .muted { color: #666; font-size: .95rem; }
    .ok { color: #0a7a19; }
    .err { color: #b00020; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    details { margin-top: 1rem; }
    summary { cursor: pointer; }
    .footer { margin-top: 2rem; font-size: .9rem; color: #666; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
</head>
<body>
  <h1>JSON → Steps (Per-Item ZIP)</h1>
  <p class="muted">No install required. Runs fully in your browser. Upload your JSON with a top-level <span class="mono">workitems</span> array.</p>

  <div class="card">
    <div class="row">
      <input id="fileInput" type="file" accept="application/json" />
      <button id="processBtn" disabled>Create ZIP</button>
    </div>
    <p id="status" class="muted">Select a JSON file to begin.</p>
    <details>
      <summary>Expected JSON shape</summary>
      <pre class="mono">{
  "workitems": [
    {
      "workItemId": "1",
      "inputData": {
        "prompt": "...",
        "model_a": "...",
        "model_b": "..."
      }
    }
  ]
}</pre>
    </details>
  </div>

  <div class="footer">Tip: Works offline after first load. Your data never leaves your device.</div>

  <script>
    // --- Formatting helpers (ported to JS to match Python script behavior) ---
    const HEADING_PATTERNS = [
      /^approach\s*:?$/i,
      /^steps?\b.*:\s*$/i,
      /^code\s*:?$/i,
      /^examples?\s*:?$/i,
      /^constraints?\s*:?$/i,
      /^notes?\s*:?$/i,
      /^explanation\s*:?$/i,
    ];

    function isHeading(line) {
      const s = line.trim();
      if (!s) return false;
      if (s.length <= 80 && s.endsWith(':')) return true;
      for (const pat of HEADING_PATTERNS) {
        if (pat.test(s.replace(/:$/, ''))) return true;
      }
      return false;
    }

    function isListLike(line) {
      const s = line.replace(/^\s+/, '');
      return (
        s.startsWith('-') ||
        s.startsWith('*') ||
        /^\d+[\.)]\s+/.test(s) ||
        /^[a-zA-Z][\.)]\s+/.test(s)
      );
    }

    function normalizeTextBlocks(text) {
      const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
      const blocks = [];
      let cur = [];
      let inCode = false;

      for (const raw of lines) {
        const line = raw.replace(/\s+$/, '');
        if (/^\s*```/.test(line)) {
          if (!inCode) {
            if (cur.length) { blocks.push(cur.join('\n').replace(/^\n+|\n+$/g, '')); cur = []; }
            inCode = true;
            cur.push(line.trim());
            continue;
          } else {
            cur.push(line.trim());
            blocks.push(cur.join('\n'));
            cur = [];
            inCode = false;
            continue;
          }
        }
        if (inCode) { cur.push(raw); continue; }
        if (line.trim() === '') {
          if (cur.length) { blocks.push(cur.join('\n').replace(/^\n+|\n+$/g, '')); cur = []; }
          continue;
        }
        cur.push(line);
      }
      if (cur.length) blocks.push(cur.join('\n').replace(/^\n+|\n+$/g, ''));
      return blocks.filter(b => b.trim());
    }

    function formatBlockToMd(block) {
      if (block.trim().startsWith('```')) return block;
      const lines = block.split('\n').map(ln => ln.replace(/\s+$/, ''));
      if (lines.length === 1 && isHeading(lines[0])) {
        const title = lines[0].replace(/:$/, '').trim();
        return `### ${title}`;
      }
      if (lines.every(ln => isListLike(ln) || !ln.trim())) {
        const norm = [];
        for (const ln of lines) {
          const s = ln.trim();
          if (!s) continue;
          if (/^\d+[\.)]\s+/.test(s) || /^[a-zA-Z][\.)]\s+/.test(s)) {
            norm.push(`- ${s}`);
          } else if (s.startsWith('*')) {
            norm.push('- ' + s.replace(/^\*\s*/, ''));
          } else if (s.startsWith('-')) {
            norm.push(s.startsWith('- ') ? s : '- ' + s.replace(/^-\s*/, ''));
          }
        }
        return norm.join('\n');
      }
      const bullets = [];
      for (const ln of lines) {
        const s = ln.trim();
        if (!s) continue;
        if (isListLike(s) || isHeading(s)) {
          bullets.push(`- ${s}`);
        } else {
          const parts = s.split(/(?<=[\.!?])\s+(?=[A-Z0-9\[(])/);
          for (let p of parts) {
            p = p.trim();
            if (p) bullets.push(`- ${p}`);
          }
        }
      }
      return bullets.join('\n');
    }

    function renderModelTextToMd(title, text) {
      const out = [ `## ${title}` ];
      for (const block of normalizeTextBlocks(text || '')) {
        out.push(formatBlockToMd(block));
        out.push('');
      }
      return out.join('\n').trim() + '\n';
    }

    function renderWorkitemMd(item, idx) {
      const wi = item || {};
      const wiId = wi.workItemId || String(idx);
      const input = wi.inputData || {};
      const prompt = (input.prompt || '').trim();
      const modelA = (input.model_a || '').trim();
      const modelB = (input.model_b || '').trim();

      const parts = [ `# WorkItem ${wiId}` ];
      if (prompt) {
        parts.push('## Prompt');
        parts.push('> ' + prompt.split('\n').map(l => l.trim()).join('\n> '));
      }
      if (modelA) {
        parts.push('');
        parts.push(renderModelTextToMd('Response A', modelA));
      }
      if (modelB) {
        parts.push('');
        parts.push(renderModelTextToMd('Response B', modelB));
      }
      return parts.join('\n').trim() + '\n';
    }

    function sanitizeForFs(name, maxlen = 60) {
      let s = (name || '').trim();
      for (const line of s.split('\n')) {
        const t = line.trim();
        if (t) { s = t; break; }
      }
      s = s.replace(/["']/g, '');
      s = s.replace(/\s+/g, '_');
      s = s.replace(/[^A-Za-z0-9._-]/g, '');
      s = s.replace(/_+/g, '_');
      if (s.length > maxlen) s = s.slice(0, maxlen).replace(/[ _.-]+$/, '');
      return s || 'item';
    }

    async function buildZipFromJson(filename, jsonText) {
      let data;
      try { data = JSON.parse(jsonText); }
      catch (e) { throw new Error('Invalid JSON: ' + e.message); }
      const workitems = Array.isArray(data?.workitems) ? data.workitems : [];
      if (!workitems.length) throw new Error('No workitems found in JSON.');

      const zip = new JSZip();
      const base = filename.replace(/\.[^/.]+$/, '');
      const outRoot = `${base}_steps`;
      const root = zip.folder(outRoot);

      workitems.forEach((item, idx) => {
        const wi = item || {};
        const wiId = wi.workItemId || String(idx + 1);
        const input = wi.inputData || {};
        const baseName = (input.prompt ? sanitizeForFs(input.prompt) : `workitem_${wiId}`);
        const folder = root.folder(`${wiId}-${baseName}`);
        const md = renderWorkitemMd(item, idx + 1);
        folder.file('index.md', md);
      });

      const blob = await zip.generateAsync({ type: 'blob' });
      const zipName = `${outRoot}.zip`;
      saveAs(blob, zipName);
      return { count: workitems.length, zipName };
    }

    const fileInput = document.getElementById('fileInput');
    const processBtn = document.getElementById('processBtn');
    const statusEl = document.getElementById('status');

    fileInput.addEventListener('change', () => {
      statusEl.textContent = fileInput.files?.[0] ? `Selected: ${fileInput.files[0].name}` : 'Select a JSON file to begin.';
      processBtn.disabled = !fileInput.files?.[0];
    });

    processBtn.addEventListener('click', async () => {
      const file = fileInput.files?.[0];
      if (!file) return;
      processBtn.disabled = true;
      statusEl.textContent = 'Processing…';
      try {
        const text = await file.text();
        const res = await buildZipFromJson(file.name, text);
        statusEl.innerHTML = `<span class="ok">Done.</span> Created <span class="mono">${res.zipName}</span> with ${res.count} items.`;
      } catch (err) {
        statusEl.innerHTML = `<span class="err">Error:</span> ${err.message}`;
      } finally {
        processBtn.disabled = !fileInput.files?.[0];
      }
    });
  </script>
</body>
</html>
